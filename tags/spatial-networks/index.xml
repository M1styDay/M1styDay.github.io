<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spatial Networks on M1sty</title>
    <link>https://www.m1sty.com/tags/spatial-networks/</link>
    <description>Recent content in Spatial Networks on M1sty</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.m1sty.com/tags/spatial-networks/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spatial Networks：Content</title>
      <link>https://www.m1sty.com/2021/atdm_3_spatial-networks_1_content/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2021/atdm_3_spatial-networks_1_content/</guid>
      <description>Spatial Networks Background Network Distance  In many real applications accessibility of objects is restricted by a spatial network  Examples  Driver looking for nearest gas station Mobile user looking for nearest restaurant     Shortest path distance used instead of Euclidean distance SP(a,b) = path between a and b with the minimum accumulated length  Challenges  Euclidean distance is no longer relevant  R-tree may not be useful, when search is based on shortest path distance   Graph cannot be flattened to a one-dimensional space  Special storage and indexing techniques for graphs are required   Graph properties may vary  directed vs.</description>
    </item>
    
    <item>
      <title>Spatial Networks：Tutorial</title>
      <link>https://www.m1sty.com/2021/atdm_3_spatial-networks_2_tutorial/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2021/atdm_3_spatial-networks_2_tutorial/</guid>
      <description>Dijkstra&amp;rsquo;s algorithm review A* search algorithm review Nearest neighbor search exercise Question Consider a spatial network database, which includes a road network graph G and a set of points of interest P. The points in P can only be located on the vertices or edges of G. Each point of interest is with some labels (at least one), e.g., &amp;lsquo;school&amp;rsquo;, &amp;lsquo;hotel&amp;rsquo;, &amp;lsquo;restaurant&amp;rsquo;. The points P are indexed by an R-tree $R_P$ based on location and by an inverted file (see the demo below) IP based on the labels.</description>
    </item>
    
    <item>
      <title>Spatial Networks：Supplement</title>
      <link>https://www.m1sty.com/2021/atdm_3_spatial-networks_4_more/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2021/atdm_3_spatial-networks_4_more/</guid>
      <description>Shortest Path Search Dijkstra&amp;rsquo;s algorithm   Dijkstra算法用来寻找图形中节点之间的最短路径。
  在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。
  在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。
  A* algorithm   A*算法通过下面这个函数来计算每个节点的优先级:
 f(n)=g(n)+h(n)  f(n)是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。 g(n) 是节点n距离起点的代价。 h(n)是节点n距离终点的预计代价，这也就是A*算法的启发函数。      A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。
  另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为open_set和close_set。
   在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。 如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。 如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。 如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。 在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。  Bi-directional search Spatial queries over spatial networks  Data:  A (static) spatial network (e.g., city map) A (dynamic) set of spatial objects   Spatial queries based on network distance:  Selections.</description>
    </item>
    
  </channel>
</rss>
