<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on M1sty</title>
    <link>https://www.m1sty.com/categories/database/</link>
    <description>Recent content in Database on M1sty</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.m1sty.com/categories/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQL面试必会50题_题解【施工中……】</title>
      <link>https://www.m1sty.com/2020/database_sql_50/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2020/database_sql_50/</guid>
      <description>材料 题源+数据 SQL面试必会50题
表关系  题解 01-10 1. 查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号 SELECT st.s_id, a.s_score, b.s_score FROM student st INNER JOIN (SELECT s_id, s_score FROM score WHERE c_id = &amp;#34;01&amp;#34;) as a on a.s_id = st.`s_id` INNER JOIN (SELECT s_id, s_score FROM score WHERE c_id = &amp;#34;02&amp;#34;) as b on b.s_id = st.`s_id` WHERE a.s_score &amp;gt; b.s_score; 2. 查询平均成绩大于60分的学生的学号和平均成绩 SELECT distinct s_id, AVG(s_score) as avg1 FROM score Group by S_id having avg1 &amp;gt; 60 3.</description>
    </item>
    
    <item>
      <title>SQL语句复习</title>
      <link>https://www.m1sty.com/2020/database_sql_sentences/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2020/database_sql_sentences/</guid>
      <description>DDL &amp;amp; DML 库操作 创建数据库 CREATE DATABASE database-name
删除数据库 drop database dbname
分离数据库 sp_detach_db
附加数据库 sp_attach_db （后接表明，附加需要完整的路径名）
修改数据库名称 sp_renamedb &amp;lsquo;old_name&amp;rsquo;, &amp;lsquo;new_name&amp;rsquo;
表操作 创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)
根据已有的表创建新表 A：create table tab_new like tab_old
B：create table tab_new as select col1,col2… from tab_old definition only
删除表 drop table tabname
增加列 Alter table tabname add column col type
添加/删除主键 Alter table tabname add primary key(col)
Alter table tabname drop primary key(col)</description>
    </item>
    
    <item>
      <title>SQL基础知识</title>
      <link>https://www.m1sty.com/2020/database_sql_notes/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2020/database_sql_notes/</guid>
      <description>表操作 创建表 create table 表名（字段名称 字段类型 约束，……） 字符类型  character 字符串  char(size) 保存固定长度的字符串 varchar(n) 可变长度的字符_最多8000个字符 text 可变长度的字符串_最多2GB字符数据   unicode 字符串  nchar(n) 固定长度的Unicode数据_最多4000个字符 nvarchar(n) 可变长度的Unicode数据_最多4000个字符 ntext 可变长度的Unicode数据_最多2GB字符数据   Binary 类型  bit 允许0/1/null binary(n) 固定长度的二进制数据_最多8000字节 varbinary(n) 可变长度的二进制数据_最多8000字节 image 可变长度的二进制数据_最多2GB   Number 类型  tinyint 允许从0到255的所有数字 int 允许从-2,147,483,648到2,147,483,647的所有数字_占4字节 bigint -9,223,372,036,854,775,808到9,223,372,036,854,775,807范围内数字_占8字节 float 从-1.79E+308到1.79E+308的浮动精度数字数据 real 从-3.40E+38到3.40E+38的浮动精度数字数据 money 10进制货币数据   Date 类型  datetime 从1753年1月1日到9999年年12月31日，精度为3.33毫秒_8bytes date 仅储存日期。从0001年1月1日到9999年12月31日_3bytes   其他数据类型  uniqueidentifler 存储全局标识符（GUID） xml 存储XML格式化数据_最多2GB cursor 存储对用于数据库操作的指针的引用   常见的字符类型选择  字符类型建议采用varchar/nvarchar数据类型 全额货币建议采用money数据类型 自增长标识建议采用bigint数据类型（int类型限制） 时间类型建议采用datetime数据类型 尽量不用text、ntext、image 尽量不用xml、varchar(max)、nvarchar(max)    不同数据库数据字符类型区别  https://www.</description>
    </item>
    
    <item>
      <title>牛客网数据库_错题集【施工中……】</title>
      <link>https://www.m1sty.com/2020/database_sql_nowcoder/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.m1sty.com/2020/database_sql_nowcoder/</guid>
      <description>mysql_db_query和mysql_query 关于mysql_db_query与mysql_query说法错误的是：(ABC)
 A.mysql_db_query与mysql_query在执行sql语句后的返回值是一样的，成功返回资源号，失败返回FALSE B.不能用mysql_query函数临时在另一个数据库上执行sql语句，而mysql_db_query可以 C.mysql_query在功能上等于mysql_select_db() + mysql_db_query() D.mysql_db_query不会切换回先前连接到的数据库  范式 下面关于数据库范式的说法哪些是正确的：（ADE）
 A.关系型数据库设计必须符合第一范式，在这种范式下一个数据列只能有一个值 B.数据库设计范式的引入，提高了数据库访问的效率 C.数据库表设计[学号，学生姓名、年龄、性别、课程号、课程名称 课程学分]满足第二范式，但不满足第三范式 D.满足第四范式必然满足第三范式，满足第三范式必然满足第二范式 E.通过数据范式的引入，可以减少数据冗余，消除数据操作异常 F.数据库设计时，符合的范式的等级越高越好  Notes 第一范式：表的每一列属性不可再分。不满足第一范式的就不是关系数据库。
第二范式：在第一范式的基础上，非主键列属性完全依赖于主键列属性。如果是组合字段主键，部分属性可能只依赖于主键中的某个字段。
第三范式：非主键列只能由主键决定，不能由其他非主键决定或导出。
数据库范式的引入，主要是为了解决数据冗余、插入异常、删除异常、更新异常等问题！
c选项，主键是【学号，课程号】，但是非主键列并不完全依赖主键，如：课程学分只依赖于课程号
日志 MySQL主从架构的主数据库中不可能出现的日志为：（C）
 A.错误日志 B.事务日志 C.中继日志 D.重做日志  Notes 主服务器将改变记录到二进制日志文件（binary log)中， 从服务器将主服务器的二进制文件拷贝到它的中继日志（relay log)中，并重新开启线程处理中继日志中的事件。
数据库系统 数据库应用系统中的核心问题是：（A）
 A.数据库设计 B.数据库系统设计 C.数据库维护 D.数据库管理员培训  数据库的锁 如果事务T获得了数据项Q上的排它锁，则T对Q：（D）
 A.只能读不能写 B.只能写不能读 C.既可读又可写 D.不能读不能写  Notes 锁的类型有三种：
共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。
排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。
更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</description>
    </item>
    
  </channel>
</rss>
